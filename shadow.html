<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Raytracer with Plane</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body
    class="bg-gray-800 flex items-center justify-center min-h-screen m-0 overflow-hidden"
  >
    <div class="w-[500px] h-[500px]">
      <canvas
        id="raytraceCanvas"
        width="500"
        height="500"
        class="w-full h-full border border-black bg-black"
      ></canvas>
    </div>

    <script>
      // --- Konseptual helper.js ---
      const vec3 = {
        create: (x = 0, y = 0, z = 0) => [x, y, z],
        clone: (a) => [a[0], a[1], a[2]],
        dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
        lengthSq: (a) => a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
        length: (a) => Math.sqrt(vec3.lengthSq(a)),
        subtract: (out, a, b) => {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          out[2] = a[2] - b[2];
          return out;
        },
        normalize: (out, a) => {
          const len = vec3.length(a);
          if (len > 0.00001) {
            const invLen = 1.0 / len;
            out[0] = a[0] * invLen;
            out[1] = a[1] * invLen;
            out[2] = a[2] * invLen;
          } else {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
          }
          return out;
        },
        add: (out, a, b) => {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          out[2] = a[2] + b[2];
          return out;
        },
        scale: (out, a, s) => {
          out[0] = a[0] * s;
          out[1] = a[1] * s;
          out[2] = a[2] * s;
          return out;
        },
        multiply: (out, a, b) => {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          out[2] = a[2] * b[2];
          return out;
        },
        clamp: (out, a, min, max) => {
          out[0] = Math.max(min, Math.min(max, a[0]));
          out[1] = Math.max(min, Math.min(max, a[1]));
          out[2] = Math.max(min, Math.min(max, a[2]));
          return out;
        },
      };
      // --- Akhir konseptual helper.js ---

      // --- Definisi Scene ---
      const spheres = [
        {
          center: vec3.create(-1.5, -0.5, 0), // Kiri (bola kecil)
          radius: 0.4,
          radiusSq: 0.4 * 0.4,
          color: [0.1, 0.1, 1.0],
          shininess: 10,
          specularFactor: 0.2,
          isPlane: false,
        },
        {
          center: vec3.create(0.0, -0.1, 0), // Tengah (bola besar)
          radius: 1.0,
          radiusSq: 1.0 * 1.0,
          color: [0.1, 1.0, 0.1],
          shininess: 100,
          specularFactor: 0.8,
          isPlane: false,
        },
        {
          center: vec3.create(1.5, -0.3, 0), // Kanan (bola agak besar)
          radius: 0.6,
          radiusSq: 0.6 * 0.6,
          color: [1.0, 0.1, 0.1],
          shininess: 32,
          specularFactor: 0.5,
          isPlane: false,
        },
      ];

      // Definisi Lantai (Plane)
      const floorPlane = {
        point: vec3.create(0, -1.0, 0), // Titik pada plane (misalnya, y = -1 adalah level lantai)
        normal: vec3.create(0, 1, 0), // Normal menghadap ke atas
        color1: [0.8, 0.6, 0.4], // Cokelat muda
        color2: [0.4, 0.2, 0.1], // Cokelat tua
        shininess: 4, // Kurang mengkilap
        specularFactor: 0.06, // Sedikit specular
        isPlane: true,
        checkerScale: 1.25, // Skala pola checkerboard
      };

      // Menggabungkan objek scene
      const sceneObjects = [...spheres, floorPlane];

      const camera = {
        origin: vec3.create(0, 0, -5),
        viewPlaneZ: -1,
      };

      const light = {
        position: vec3.create(-3, 5, -3), // Naikkan sedikit posisi cahaya
        color: [1.0, 1.0, 1.0],
        intensity: 1.0,
      };

      const ambientLight = {
        color: [1.0, 1.0, 1.0],
        intensity: 0.15,
      };

      const backgroundColor = [0.1, 0.1, 0.2];

      // --- Fungsi Ray-Sphere Intersection ---
      function intersectSphere(rayOrigin, rayDirection, sphere) {
        const oc = vec3.create();
        vec3.subtract(oc, rayOrigin, sphere.center);
        const a = vec3.dot(rayDirection, rayDirection); // Sebenarnya selalu 1 jika rayDirection dinormalisasi
        const b = 2.0 * vec3.dot(oc, rayDirection);
        const c = vec3.dot(oc, oc) - sphere.radiusSq;
        const discriminant = b * b - 4 * a * c;

        if (discriminant < 0) {
          return Infinity;
        } else {
          const t1 = (-b - Math.sqrt(discriminant)) / (2.0 * a);
          const t2 = (-b + Math.sqrt(discriminant)) / (2.0 * a);
          if (t1 > 0.001) return t1; // Pilih t positif terkecil
          if (t2 > 0.001) return t2;
          return Infinity;
        }
      }

      // --- Fungsi Ray-Plane Intersection ---
      function intersectPlane(rayOrigin, rayDirection, plane) {
        const N = plane.normal;
        const P0 = plane.point;
        const denominator = vec3.dot(N, rayDirection);

        // Jika denominator > 0, normal plane dan arah ray berlawanan (ray menuju sisi belakang plane)
        if (Math.abs(denominator) > 0.0001) {
          const p0l0 = vec3.create();
          vec3.subtract(p0l0, P0, rayOrigin);
          const t = vec3.dot(p0l0, N) / denominator;
          if (t > 0.001) {
            return t;
          }
        }
        return Infinity;
      }

      // --- Logika Rendering Utama ---
      const canvas = document.getElementById("raytraceCanvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      const aspectRatio = width / height;
      const renderScale = 2.0; // Viewport scale

      const ambientColor = vec3.scale(
        vec3.create(),
        ambientLight.color,
        ambientLight.intensity
      );
      const lightColorIntensity = vec3.scale(
        vec3.create(),
        light.color,
        light.intensity
      );

      console.log("Starting Raytrace (Phong Lighting + Plane)...");
      const startTime = performance.now();

      // Tambahkan ini di luar render loop
      const MAX_BOUNCE = 3;
      const EPSILON = 0.001;

      // Fungsi untuk trace sinar dan menghitung warna (rekursif untuk refleksi)
      function traceRay(origin, direction, bounce) {
        if (bounce > MAX_BOUNCE) return backgroundColor;

        let closestT = Infinity;
        let hitObject = null;

        for (const obj of sceneObjects) {
          let t = obj.isPlane
            ? intersectPlane(origin, direction, obj)
            : intersectSphere(origin, direction, obj);
          if (t > EPSILON && t < closestT) {
            closestT = t;
            hitObject = obj;
          }
        }

        if (!hitObject) return backgroundColor;

        // Hit point
        const hitPoint = vec3.create();
        vec3.scale(hitPoint, direction, closestT);
        vec3.add(hitPoint, origin, hitPoint);

        // Normal dan warna objek
        let normal, objectColor;
        if (hitObject.isPlane) {
          normal = vec3.clone(hitObject.normal);
          const checkerVal =
            (Math.floor(hitPoint[0] * hitObject.checkerScale) +
              Math.floor(hitPoint[2] * hitObject.checkerScale)) %
            2;
          objectColor = checkerVal === 0 ? hitObject.color1 : hitObject.color2;
        } else {
          normal = vec3.create();
          vec3.subtract(normal, hitPoint, hitObject.center);
          vec3.normalize(normal, normal);
          objectColor = hitObject.color;
        }

        // Arah cahaya dan view
        const lightDir = vec3.create();
        vec3.subtract(lightDir, light.position, hitPoint);
        vec3.normalize(lightDir, lightDir);

        const viewDir = vec3.create();
        vec3.subtract(viewDir, camera.origin, hitPoint);
        vec3.normalize(viewDir, viewDir);

        // Cek shadow
        const shadowOrigin = vec3.create();
        vec3.scale(shadowOrigin, normal, EPSILON);
        vec3.add(shadowOrigin, hitPoint, shadowOrigin);
        let inShadow = false;

        for (const obj of sceneObjects) {
          let t = obj.isPlane
            ? intersectPlane(shadowOrigin, lightDir, obj)
            : intersectSphere(shadowOrigin, lightDir, obj);
          if (t > EPSILON && t < vec3.length(lightDir)) {
            inShadow = true;
            break;
          }
        }

        // Ambient
        const ambientTerm = vec3.create();
        vec3.multiply(ambientTerm, objectColor, ambientColor);

        const diffuseTerm = vec3.create();
        const specularTerm = vec3.create();

        if (!inShadow) {
          // Diffuse
          const dotNL = Math.max(0.0, vec3.dot(normal, lightDir));
          vec3.multiply(diffuseTerm, objectColor, lightColorIntensity);
          vec3.scale(diffuseTerm, diffuseTerm, dotNL);

          // Specular
          const halfwayDir = vec3.create();
          vec3.add(halfwayDir, lightDir, viewDir);
          vec3.normalize(halfwayDir, halfwayDir);
          const dotNH = Math.max(0.0, vec3.dot(normal, halfwayDir));
          const specularIntensity =
            Math.pow(dotNH, hitObject.shininess) * hitObject.specularFactor;
          vec3.scale(specularTerm, lightColorIntensity, specularIntensity);
        }

        // Reflected ray
        const reflectDir = vec3.create();
        const dotNV = vec3.dot(normal, direction);
        for (let i = 0; i < 3; i++) {
          reflectDir[i] = direction[i] - 2 * dotNV * normal[i];
        }
        vec3.normalize(reflectDir, reflectDir);

        const reflectOrigin = vec3.create();
        vec3.scale(reflectOrigin, normal, EPSILON);
        vec3.add(reflectOrigin, hitPoint, reflectOrigin);

        const reflectColor = traceRay(reflectOrigin, reflectDir, bounce + 1);

        const result = vec3.create();
        vec3.add(result, ambientTerm, diffuseTerm);
        vec3.add(result, result, specularTerm);
        vec3.add(result, result, reflectColor); // Refleksi langsung ditambahkan

        return vec3.clamp(result, result, 0, 1);
      }

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let colorSum = vec3.create();

          for (let dy = 0; dy < 2; dy++) {
            for (let dx = 0; dx < 2; dx++) {
              const sx = x + (dx + 0.5) / 2;
              const sy = y + (dy + 0.5) / 2;

              const viewportX =
                ((sx / width) * 2 - 1) * aspectRatio * renderScale;
              const viewportY = (1 - (sy / height) * 2) * renderScale;

              const pixelDir = vec3.create(
                viewportX,
                viewportY,
                camera.viewPlaneZ
              );
              vec3.subtract(pixelDir, pixelDir, camera.origin);
              vec3.normalize(pixelDir, pixelDir);

              const sampleColor = traceRay(camera.origin, pixelDir, 0);
              vec3.add(colorSum, colorSum, sampleColor);
            }
          }

          vec3.scale(colorSum, colorSum, 1 / 4);
          const idx = (y * width + x) * 4;
          data[idx] = Math.floor(colorSum[0] * 255);
          data[idx + 1] = Math.floor(colorSum[1] * 255);
          data[idx + 2] = Math.floor(colorSum[2] * 255);
          data[idx + 3] = 255;
        }

        if (y % 50 === 0 && y > 0) {
          console.log(`Rendering... ${Math.round((y / height) * 100)}%`);
        }
      }

      ctx.putImageData(imageData, 0, 0);

      const endTime = performance.now();
      console.log(
        `Raytrace finished in ${((endTime - startTime) / 1000).toFixed(
          2
        )} seconds.`
      );
    </script>
  </body>
</html>
